// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Which login provider the user is using
enum AuthProvider {
  /// classic email + password combo
  local
  google
}

enum Role {
  USER
  ADMIN
}

model Account {
  id       String       @id @default(uuid())
  /// An account created through Google or other providers won't have a username immediately
  /// We need to create the account and then prompt the user for a username
  username String?      @unique
  email    String       @unique
  provider AuthProvider
  /// If Provider is not AuthProvider.local, we won't have a password for that Account
  password String?
  role     Role         @default(USER)

  auctions Auction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CarBrand {
  name String @id

  models CarModel[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CarModel {
  name         String
  carBrandName String

  brand                 CarBrand                @relation(fields: [carBrandName], references: [name])
  auctionCarInformation AuctionCarInformation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([name, carBrandName])
}

/// The AuctionCarInformation model represents a set of data about the car, with a 1:1 relation to an Auction
/// user-entered fields (`ueCarBrand` and `ueCarModel`) 
/// verified fields (`carBrandName` and `carModelName`), which may 
///
/// - `ueCarBrand` and `ueCarModel`: Capture raw input from the user at the time of submission
///
/// - `carBrandName` and `carModelName`: Link to the `CarBrand` and `CarModel` tables, respectively, after admin approval.
model AuctionCarInformation {
  id String @id @default(uuid())

  vin        String
  /// user entry(ue) car brand, once the auction is verified, we either create that brand or we connect it a existing brand
  ueCarBrand String
  /// user entry(ue) car model, once the auction is verified, we either create that model or we connect it a existing model
  ueCarModel String
  modelYear  Int
  /// Exact trim of the model: GTI, GT3RS, Competition, etc.
  trim       String?
  /// in km
  mileage    Int

  carModel     CarModel? @relation(fields: [carModelName, carBrandName], references: [name, carBrandName])
  carModelName String?
  carBrandName String?
  auction      Auction?
  auctionId    String?   @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ContactType {
  PRIVATE
  DEALER
}

model ContactDetails {
  id String @id @default(uuid())

  /// If type is private, name is full name of the private person
  name       String?
  /// If type is dealer, name is name of the delaership/company
  dealerName String?
  type       ContactType
  phone      String

  auction   Auction?
  auctionId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum AuctionState {
  /// The initial state when a user first submits an auction with only basic info, which then needs to be approved by an admin
  SUBMITTED
  /// After the auction has been approved by an admin, we ask for photos of the car, and we might also ask
  /// the seller for some more information about the car. It is possible that an auction will return to this state multiple times
  /// as a seller might provide incorrect or insufficient information about a car multiple times
  PENDING_CHANGES
  /// After the user submits their photos and other info, the state goes to UNDER_REVIEW, where an admin has to again
  /// look at the auction and decide if the auction is ready to go LIVE or back to PENDING_CHANGES
  UNDER_REVIEW
  /// Auction is live and can be publicly seen
  LIVE
  /// Auction has been rejected for some reason
  // TODO: We should somewhere save the reason why it was rejected
  REJECTED
}

model Auction {
  id String @id @default(uuid())

  state AuctionState

  carInformation   AuctionCarInformation @relation(fields: [carInformationId], references: [id])
  carInformationId String                @unique
  seller           Account               @relation(fields: [sellerId], references: [id])
  sellerId         String
  contactDetails   ContactDetails        @relation(fields: [contactDetailsId], references: [id])
  contactDetailsId String                @unique
  media            Media[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Media {
  id String @id @default(uuid())

  /// Relative path to the media: "/images/auctions/auction-id-1/image1.jpg"
  path String
  /// Full URL to the media: "http://localhost:8080/images/auctions/auction-id-1/image1.jpg"
  /// I chose to do it this way because I am not sure where I will be hosting the images, and it may change in the future
  /// Also it's easier for the frontend.
  url  String @unique

  auctionId String?
  auction   Auction? @relation(fields: [auctionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
